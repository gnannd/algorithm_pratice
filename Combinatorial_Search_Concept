보통 Dynamic_method 나 Divide_Conquer 등 적절히 적용하면 유용하긴 한데,
동적계획법 같은 경우는 메모리문제나 중복되는 문제가 전혀 없을 경우 못쓸거고
분할 정복은 적절한 분할 방법이 없으면 못쓸건데 그러면 결국 brute_force로 돌아오게 된다.
완전탐색을 포함해, 유한한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘들을 combinatorial search 라고 하겠다.
결국 모든 답을 고려하게 될텐데, 보통 문제의 크기에 따라 기하급수적으로 탐색해야할 크기가 늘어날 것 이다.
이 문제에 대해 조합 탐색에 대한 다양한 최적화 기법이 있고 이들은 접근방식은 다르지만
모두 최적해가 될 가능성이 없는 답들을 탐색하는 것을 방지하여 만들어 보야 할 답의 수를 줄이는 것을 목표로 한다.

조합 탐색 최적화 기법들은 크게 두가지로 분류.
-가지치기(pruning): 탐색 과정에서 최적해로 연결 될 가능성이 없는 부분들을 잘라내는 것. -> 존재하는 답 중의 일부를 아예 만들지 않기 때문에 동작속도 up
 
-탐색의 순서를 바꾸거나, 탐색 시작전에 탐욕법 이나 휴리스틱을 이용해 적당히 좋은 답 우선 찾아내기. ++pruning 함께 사용하면 좋음.

휴리스틱(heuristic): '경험에 의거한'문제 풀이 기법. 사람의 어림짐작으로 문제를 푸는 과정을 알고리즘으로 옮긴 것. 
++항상 최적의 답을 찾아 내지는 못하지만, 어느 정도 현실에 가까운 답을 빨리 찾기 위한 용도로 자주 사용.
주의: 어림짐작이기 때문에 과소평가, 즉 예상값을 적당히 낮춰 문제의 최적해를 못찾는 일을 방지하자.
휴리스틱 함수를 만드는 TIP: 단순한 형태의 문제로 바꿔 푸는 것

