/*백준 23974 짝수 게임

a,b 플레이어가 있고 a는 동전을 n개(0~1)를 가지고 시작한다. 각플레이어가 
판에 놓인 동전k(1~10000000)을 모두가져갈때까지 a부터 1~4개씩 가져가면 되는데,
마지막에 a가 짝수개의 동전을 가지고 있으면 a가 승리아니면 b가 승리하는 매커니즘이다.

이떄 n,k가주어지고,각 플레이어는 최적의 방법을 수행한다고 했을 때, 누가 이기냐.

브루트포스로 먼저 생각해보면, 매수행마다 가능하다면 1~4개 동전을 가져가는 선택들을 할 수 있다.
모든 경우의 수의 결과는 4가지 종류가 있는데, 동전이 0개가되고 다음 플레이가 a면 a입장에서 a가 가진동전개수가
짝수면 승리이고, 홀수면 패배, 다음플레이어가 b면 b입장에서 a의 동전의개수가 짝수면 패배, 홀수면 승이다.

최적의 방법을 한다는 것은,
내가 할 수 있는 선택지 중 하나라도 상대플레이어가 지는 선택지가 있으면 무조건 그것을 택할 것이다.
그러면 무조건 승리할 수 있게 된다.
내가 패배하는 경우는 내가 지금 어떠한 선택지를 하더라도 다음 상대플레이어가 이기는 상황이다.

재귀함수를 이용해 top down방식으로 구현을 해보면, 판때기에 남은 동전의 개수가 있고 a가 
현재 가진는 동전의 개수랑, 지금 어떤 플레이어 차례인지를 입력으로 받아 할 수 있는 선택지의 모든 결과를 보고 상대가 지는 선택지가 하나라도 있으면 true
없으면 false를 반환하게 구현하면 된다. 

이렇게 보면 이 입력의 형태가 같으면 같은 출력값이 나온다는 걸 알수 있고, 이걸 다이나믹으로 바꿔서 
풀 수 있게 된다.
하지만 k가 천만이하이고, a플레이어가 가질수 있는 개수도 천만이하다. 당연히 시간내에 풀 수 없는데,
여기서 잘생각해보면 a플레이어는 가진 동전의개수가 짝수인지만 판단하면 된다.
a가 얼마를 가졌든 짝수면 앞으로의 게임으로 짝수개의 동전을 가져야하고, 홀수면 홀수개의 동전을 가져야 하기 때문이다.
a의 크기를 홀수짝수인지만 판단하는 2개의 상태로 바꿀수 있다.
문제는 512mb 메모리, 1초시간 제한이 있는데,
이렇게만 보면 시간복잡도가 O(k)고 코드가 간단하여 1초 내에 수행가능할거라 보고,
메모이제이션을 char형식으로 구현해 예상 메모리를 40mb로 생각해 메모리제한도 문제없을거라 봤다.

하지만 메모리 초과가 나고, 이유는 두가지였는데, 첫번째는 백준에서는 문제없는데 테스트 환경 문제로,
memo를 정적변수로 선언하여 stack에 저장하게 되는데, 환경상에서 stack 메모리(8~16mb)가 초과난것이다. 이걸 전역변수로 선언해
데이터 영역에 저장함으로써 해결하였고,
두번째 문제는 함수 호출의 깊이 문제였다. 문제상 top down로 구현하게 되면 
k가 천만 이하다 보니 함수 호출의 깊이가 깊어질수록 또 그만큼 함수호출에 드는 메모리도 필요하게 되고 
그러다 메모리 초과가 난것으로 보였다. 

이 문제를 해결하기위해 top down방식이 아닌 bottom up 방식으로 구현했고 제한시간내에 메모리 초과없이 잘 수행되었다.
그리고 bottom up방식으로 구현하면서 알게 된것인데, 이렇게 구현하게 되면 현재 판의 동전의 개수 아래의 
상태값은 이미 다 구해진 상태이고, 현재 필요한 상태값은 현재 판의 동전의 개수에서 -1,-2,-3,-4 인 이전부분의 4개의 상태만 필요하기 때문에 
k(남은 동전의 개수)의 영역을 4로 줄어버릴 수 있다. top down의 경우는 k의 모든 값 상태를 저장을 해둬야 하지만, bottom up의 경우 모두 
저장할 필요없이 이전 상태 4개만 저장하면 되는 것이다. 차피 결과는 제일 위 상태값을 출력하기 때문이다.

아무튼 이문제는 우리가 아는 게임이론에, 다이나믹을 더한 문제였다. 괜찮은 문제인듯.
*/


#include <iostream>
#include <vector>
using namespace std;


int main()
{
    int n,k;
    cin>>n>>k;
    bool memo[10000001][2][2];
    memo[0][0][0]=true;
    memo[0][1][0]=false;
    memo[0][0][1]=false;
    memo[0][1][1]=true;
    for(int i=1;i<=k;i++)
    {
        for(int p=0;p<=1;p++)
        {
            for(int player=0;player<=1;player++)
            {
                bool ok=false;
                for(int j=4;j>=1;j--)
                {
                    if(i>=j)
                    {
                        if(player==0)
                        {
                            if(!memo[i-j][(p+j)%2][1])
                                ok=true;
                        }
                        if(player==1)
                        {
                            if(!memo[i-j][p][0])
                                ok=true;
                        }
                    }
                }
                memo[i][p][player]=ok;
            }
        }
    }
    
    
    if(memo[k][n][0]) cout<<"YG";
    else
        cout<<"HS";

    return 0;
}
