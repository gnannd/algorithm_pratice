/*
백준 11509
문제가 직관적으로 보고 풀 수 있었다. 화살의 수를 최소화 하는 문제이고 화살은 왼쪽에서 오른쪽으로 풍선을 맞출 때 까지 날라가는데 맞추면 한칸아래로 떨어져 계속 또 맞출 때까지 날아간다. 왼쪽 풍선부터 오른쪽으로 각 풍선의 높이가 주어 진다.
일단 이 문제는 n이 최대가 백만이라 o(n) 알고리즘을 택해야 겠다는 생각이 들었다.
 화살을 써야 하는 순간을 생각해봤다.
풍선을 맞추면 그 화살은 한칸 아래로 내려간다. 
그리고 왼쪽 부터 풍선을 쭉 훎을 때 당시 풍선이 화살을 써야 하나 안써도 되냐의 판단을 바로 할 수 있게끔 하면 
o(n) 알고리즘으로 풀 수 있을거 같았다.
그래서 각 화살을 풍선을 훑는거에 따라 현재상태를 계속 업데이트 해줬다
맞출 화살이 없으면 answer+1 하고 높이-1 에 화살이 하나 존재 
맞출 화살이 있으묜 높이에 화살 개수를 1 줄이는 식으로 
각 풍선을 훑을 때 바로 판단이 가능하도록 구현했다.
현재 풍선에 대해 그전에 날린 모든 화살들의 위치를 가지고 있으니까 이 풍선에 화살을 하나 소모해야 하는지 그전에 화살로 풍선이 맞춰지는지 바로 알 수 있었다.
시간복잡도는 o(n) 으로 시간안에 풀 수 있을 것이고 실제로도 그랬다. 

*/


#include <iostream>
#include <vector>

using namespace std;

int main(int argc, char *argv[])
{
	int n;
	cin>>n;
	vector<int>num(n);
	for(int i=0;i<n;i++)
	    cin>>num[i];
	vector<int>cnt(1000001,0);
	int answer=0;
	for(int i=0;i<n;i++)
	{
		if(cnt[num[i]]==0)
		{
			answer+=1;
			if(num[i]!=1)
			    cnt[num[i]-1]+=1;
		}
		else
		{
			cnt[num[i]]-=1;
			if(num[i]!=1)
			    cnt[num[i]-1]+=1;
			
		}
	}	
	cout<<answer;
}