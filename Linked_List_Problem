/*백준 23309번 철도공사
번호가 나열되고 각 번호고 원형으로 연결 되어있다.
각번호사이에 번호가 삽입될 수 있고 현재 있는 번호가 삭제될 수 있다.
그런과정을 하는 동안 삽입될때는 삽입되는 번호앞의 번호를 삭제될 때는 삭제되는 번호를
출력하는 프로그램을 작성하는 문제이다.

처음에 주어지는 번호의 개수는 50만이하, 삽입,삭제 과정 횟수가 150만이하로 나와있다.
그리고 주어지는 번호의 범위는 1부터 100만 이하이고 중복으로 주어지지 않는다.
<풀이>
자료구조는 연결리스트, 배열 둘다 쓰기로 했다.
연결리스트를 쓰는 이유는 삽입 삭제과정을 O(1)만에 하기 위해서이다. 과정횟수가 150만이하이므로,
삽입 삭제과정에서 번호 개수에 시간이 선형비례하면 제한시간내에 풀지 못할 것이기 때문이다.

그리고 배열을 같이 쓰는 이유는 연결리스트가 랜덥 접근에 번호의 개수에 비례하기 때문에 
번호의 개수가 최대 100만이하, 과정 횟수가 150만이하라 
배열과 연결리스트 둘다 사용하여 풀기로 하였다.

시간복잡도: O(M), M은 150만 이하

시간내에 수행되기 했는데, 입력받는 문자열의 크기가 커 아슬아슬하게 통과 되었다..
*/

#include <iostream>
#include <list>
#include <vector>

using namespace std;

int main()
{
    //입력 문자열의 크기가 커 동기화를 풀겠다.
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    
    int n,m;
    cin>>n>>m;
    
    list<int>lt;  //참고로 iter이 가르키는 노드가 사라지면 iter무효화 됌.
    vector<list<int>::iterator>access(1000001); // i 번호를 가르키는 iter 값.
    list<int>::iterator iter;
    iter=lt.begin();
    for(int i=0;i<n;i++)
    {
        int num;
        cin>>num;
        access[num]=lt.insert(iter,num);// list에 num을 삽입하고 삽입한 노드를 가르키는 iter
    }
    
    for(int i=0;i<m;i++)
    {
        string cmd;
        cin>>cmd;
        if(cmd=="BN") //주어진 번호 p1 다음 위치번호 출력하고 그위치에 넣을려 하는 번호 p2 삽입.
        {
            int p1,p2;
            cin>>p1>>p2;
            iter=access[p1];
            iter++;
            if(iter==lt.end()) iter=lt.begin();
            cout<<*iter<<'\n';
            access[p2]=lt.insert(iter,p2);
        }
        else if(cmd=="BP")
        {
            int p1,p2;
            cin>>p1>>p2;
            iter=access[p1];
            if(iter==lt.begin()) iter=lt.end();
            iter--;
            cout<<*iter<<'\n';
            access[p2]=lt.insert(access[p1],p2);
        }
        else if(cmd=="CN") //주어진 번호 p1의 다음 번호를 없애고 그 값을 출력
        {
            int p1;
            cin>>p1;
            iter=access[p1];
            iter++;
            if(iter==lt.end()) iter=lt.begin();
            cout<<*iter<<'\n';
            lt.erase(iter);
        }
        else 
        {
            int p1;
            cin>>p1;
            iter=access[p1];
            if(iter==lt.begin()) iter=lt.end();
            iter--;
            cout<<*iter<<'\n';
            lt.erase(iter);
        }
    }
    
    return 0;
}
