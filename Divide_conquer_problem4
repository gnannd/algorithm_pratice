/*
백준 17829번 
N이 주어지고 N*N을 조건에따라 2배씩 크기를 줄여나가 1X1이 됐을 때 어떤값이 남는지 묻는 문제다(N은 2의 거듭제곱 수로 주어지므로 문제를 푸는데 어려움이 없다.)
전형적인 분할 정복알고리즘을 이용하여 풀 수 있는 문제로 조건에 맞게 풀어나가면 된다. 
이 문제는 처음부터 가로 세로 두배씩 1x1이 되기전까지 분할 하여 다시 merge한다. 이때 조건에 맞게 크기가 두번째 인얘로 계속 합쳐 나가면 된다.
참고로 1x1일 때는 그대로 반환하면 된다.
깊이는 두배씩 줄여드니까 lgn , 그리고 탐색을 n^2라 생각하면.
n의 크기가 1024가 최대므로 충분히 시간안에 풀 수 있다.
시간복잡도 O(n^2 * lgn)
++ 더하여 별건 아니지만 값의 크기가 애초에 int 범위를 넘어가지 않기에 int 쓰면 된다.
실제로 제한시간 1초안에 수행되었다.
*/
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int GetSecond(vector<vector<int>>&square,int x1,int y1,int x2,int y2)
{
    if(x1==x2) //분할을 하는데 1x1이면 그대로 반환 
    {
        return square[x1][y1];
    }
    vector<int>num;
    num.push_back(GetSecond(square,x1,y1,(x2+x1)/2,(y1+y2)/2));
    num.push_back(GetSecond(square,(x2+x1)/2+1,y1,x2,(y1+y2)/2));
    num.push_back(GetSecond(square,x1,(y1+y2)/2+1,(x2+x1)/2,y2));
    num.push_back(GetSecond(square,(x2+x1)/2+1,(y1+y2)/2+1,x2,y2));
    sort(num.begin(),num.end(),greater<int>());
    
    return num[1];
}

int main()
{
    int n_size=0;
    cin>>n_size;
    
    vector<vector<int>>square(n_size,vector<int>(n_size,0));
    for(int i=0;i<n_size;i++)
    {
        for(int j=0;j<n_size;j++)
        {
            cin>>square[i][j];
        }
    }
    
    
    cout<<GetSecond(square,0,0,n_size-1,n_size-1);
    
    return 0;
}
