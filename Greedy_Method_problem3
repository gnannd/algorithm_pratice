/* 백준 1083
s번이하 이웃한거 끼리 교환하여 사전순으로 제일 뒷 수열이 된걸 찾는 문제로
s번이하 교환하여 만들 수 있는 모든 조합을 생각하는 브루트 포스를 생각 할 수 있다.

첫번째 자리에 어떤 숫자를 선택할 지 매 자리마다 모든 조합을 택하는 식으로 풀면 되는데,
몇번째 자리인지,남은 수열, s 를 입력으로 받아 푸는 다이나믹으로도 풀 까 생각할 수도 있지만,
이 문제는 그리디로 증명이 필요없을 정도로 자명해서 쉽게 풀 수 있다.

사전순 맨 뒷번호가 되게 하는 방법은 앞 자리부터 어떤 숫자가 올지 정할 때 s번이하 한해서 제일 큰 숫자가 올 수 있게 끔 하면된다.
그렇지 않은 답이 있다고 하면, 내가 하는 방식으로 바꿨을 때 무조건 더 나은 답이 나오게 되기 때문에 이것은
증명이 어렵지 않게 직관적으로 생각 할 수 있었다. 앞자리가 제일 큰 숫가 오게 되면 그 숫자말고 다른 걸 선택한 경우는 아무리 뒤에 잘 선택해도 답이 될 수 없다는걸 알 수 있다.
n이 50이하로 n^2풀이로 충분히 시간 내에 풀 수 있다.
시간 복잡도는 O(n^2)
실제로 0ms 가깝게 나올 정도로 많은 여유시간내에 풀었다.
*/

#include <iostream>

#include <vector>

using namespace std;

int main(int argc, char *argv[])

{

	int n=0,s=0;	

	

	cin>>n;
    vector<int> number(n);
	for(int i=0;i<n;i++)

	    cin>>number[i];

	cin>>s;

	

	for(int i=0; i<n; i++)

	{

		// 누굴 선택할지 순회 

		int choice=i;

		int max1=number[i];

		for(int j=i+1; j<n; j++)

		{

			if(j-i <= s and max1<number[j])

			{

				choice=j;

				max1=number[j];

			}

		}

		

		// 선택한걸 적용

		

	    s-=choice-i;

	    for(int j=choice;j>i;j--)

	        number[j]=number[j-1];

	    number[i]=max1;

	}

	

	for(int i=0; i<n;i++)

	    cout<<number[i]<<' ';

	

	

}
