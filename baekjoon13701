/*백준 13701
n개의 정수를 일고 이들 중 중복되는 수를 제외하고 남은 수를 출력 하는 문제이다.
n 500만 이하 고 주어지는 값은 2^25승 이하 0이상 정수이다.
자료형은 int 면 충분히 범위 내 값을 표현 할 수 있다.
그리고 메모리가 8mb 이하이다.
이 말은 즉, 겂을 인자로 하여 중복 되는 값을 체크하는 기능을 가지면서 메모리를 절약 할 수 있는 알고리즘을 찾는것으로 생각했다.
바로 생각났던 건 트리를 이용하거나 정렬하여 바이너리 서치를 이용하는 것이었다.
근데 메모리 제한 8mb 이하라는 걸 생각하면 제한 되는건 입력받는 데이터를 다 저장하는건 불가능하다는 것이다. N은 500만이하니까 최악의 경우 8mb를 한참넘어서게 됌
그래서 생각 한 방식은 나머지연산 과 비트마스킹을 이용한 방법이다.
1.나머지연산으로 메모리의 크기를 줄여 중복체크를 시도.
2.나머지연산으로 메모리가 줄어드는 대신 겹치는 값이 생겨 그 값들을 구별을 위해 비트마스킹 즉 비트로 구별. 
150만 정도로 메모리를 잡으면 메모리를 초과하지 않으면서도 중복 검색도 O(1)만에 가능하니까 시간안에도 수행될것으로 보았다.
추가로 메모리를 150만 잡은이유는 비트마스킹 할 때 int 자료형 범위를 안넘어가게 하기 위해 안전한 값으로 택한것이다.

실제로 660ms로 풀리긴 했다.
일단 처음에는 시간초과가 났는데 알고리즘에 문제는 없어 cin 입출력 특성상 버퍼 동기화 때문에 느려졌을 거라 생각해(N이 크기 때문에)
동기화를 끄고 진행하니까 660ms 안으로 풀렸다. 

버퍼 동기화를 좀더 찾아보니 출력이 꼬이지 않고 안전하게 동작하게 위해 stdio와 동기화를 맞추는 기능 때문에 느려진것인데 (입출력 힐 때마다)
사실 scanf를 안쓰기 때문에 동기화 꺼도 상관없다. 섞어 쓰게 되는 환경에서는 사용 안하면 된다.

그리고 추가로 몇가지 더 성능개선을 해봤다.
다음은 mod 값,동기화 여부에 따른 결과다.

메모리 150만 cin 버퍼동기화 - 시간 초과 
메모리 150만 cin 버퍼동기화 x -660ms
메모리 120만 cin 버퍼동기화 x - 768ms
메모리 155만 cin 버퍼동기화 x -672ms
메모리 160만이상 부터는 메모리초과

메모리가 크면 클수록 연산 횟수가 줄어들기에 속도가 개선되었다.
그에 따른 메모리도 함께 증가했다.
*/

#include <iostream>
#include <vector>
#define mod 1500000
using namespace std;

int main()
{
    ios_base :: sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    vector<int>ary(mod,0);
    while(1){
        int num;
        cin>>num;
        if(cin.eof()) break;
        if((ary[num%mod]&(1<<(num/mod)))==0)
        {
            cout<<num<<' ';
            ary[num%mod]|=(1<<(num/mod));
        }
    }
    
    return 0;
}
