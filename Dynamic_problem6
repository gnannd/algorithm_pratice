//백준 12869

#include <iostream>
#include <vector>
#include <algorithm>
#include <cstring>

//세개의 수 (<60)에서 매 시행을 거쳐(-9,-6,-1 각각을 아무 수에나 뺀다. 단, 같은 수에 중복으로 뺄수 없다.) 각 수가 0이하가 되도록 하는 최소 시행을
//찾는 문제이다.
// (1<=N<=3) 으로 N이 크지 않다., 또한 세개의 수 또한 값의 크기가 크지않다. -> 모든 시행의 조합으로 푸는 브루트 포스로 생각할 수 있다.
//n이 3이라고 가정하고 매 시행마다 모든 방법의 수 6가지가 있고 6^시행횟수 가 나온다.

//더 좋은 방법으로는 다이나믹이 있는데, 남아있는 수들의 값이 같을 수록 같은 결과 값이 나와야 한다.
//즉, 남아 있는 수들의 입력이 주어졌을 떄, 같은 값이면 항상 일정한 출력이 나온다. -> 메모이제이션을 이용한다. ++ 더하여 순서가 중요하지 않기에 정렬시켜 입력한다.
//매 시행마다 방법의 수 n!이 있다.  N!
//상태의 수 60^N/ N! (순서는 중용하지 않기에.)
//시간복잡도를 계산해보면 O(60^N)이다. 60^N / N!(순서의 크기는 중요하지않기에) * N!(매시행 방법의 수)= 60^N
//N 이 최대가 3인걸 감안하면 충분히 풀 수 있다. -> 실제로 0ms 가 나왔다.

using namespace std;

int state[61][61][61]; //큰값 순으로 정렬.
int conbine[6][3]={{9,3,1},{9,1,3},{3,1,9},{3,9,1},{1,3,9},{1,9,3}}; //경우의 수가 크지 않기에 편리한 계산을 위해 먼저 계산 했다. 

int Min_count(vector<int> &scv_hp)
{
    sort(scv_hp.begin(),scv_hp.end(),greater<int>()); //큰순으로 정렬 nlog(n)인데 n크기가 3이여서 없는 수준임.
    
    if(scv_hp[0]==0) // 모든 scv 가 0이면.
        return 0;
        
    int &ret=state[scv_hp[0]][scv_hp[1]][scv_hp[2]];
 
    if(ret != -1) return ret;
    
    ret=1e9;
    
    for(int i=0;i<6;i++)
    {
        vector<int>re_scv_hp(3,0);
        re_scv_hp[0]=max(scv_hp[0]-conbine[i][0],0);
        re_scv_hp[1]=max(scv_hp[1]-conbine[i][1],0);
        re_scv_hp[2]=max(scv_hp[2]-conbine[i][2],0);
        
        ret=min(ret,Min_count(re_scv_hp)+1);
        
    }
    
    return ret;
}

int main()
{
    int n=0;
    cin>>n;
    
    memset(state, -1, sizeof(state)); //-1로 다 초기화
    
    vector<int>scv_hp(3,0); //코드를 편하게 짜기위해 크기 3으로 고정.
    
    for(int i=0;i<n;i++)
        cin>>scv_hp[i];
    
    
    cout<<Min_count(scv_hp);
    
    

    return 0;
}
