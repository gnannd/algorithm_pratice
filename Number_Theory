정수론에 관련된  가장 기초적인 알고리즘들

-소수(prime_number)
양의 약수가 1과 자기 자신 두 개 뿐인 자연수 -> 반대말로 3개이상 약수를 갖는 자연수를 합성수 라고 한다.
1은 합성수도 아니고 소수도 아님.

*기초적인 소수판별 알고리즘
p*q로 표현되는 자연수 n에 대해 루트n까지 순회하면서 나누어지는지 시도하기.

*에라토스테네스의 체
소수를 찾을 때 마다 그배수들을 지우는 형태로 각 수m이 소수인지 판단하기 위해 루트m까지의 모든 수로 나눠 보는 기초적인 알고리즘에 비해 훨 씬 빠르게 수행됌.
시간복잡도는 거의 O(n)과 비슷하다고 생각하면됌(실제는 어떤 정리에 의해 O(nloglogn)임).
여러 형태로 변형할 수 있기 때문에 여러 정수론 문제를 푸는데 유용하게 사용됌.

-소인수 분해(prime_fac-torization)
합성수를 소수들의 곱으로 표현하는 방법

*기초적인 소인수분해 알고리즘
2부터 시작해 n의 소인수가 될 수 있는 수들을 하나하나 순회하면서 n의 약수를 찾을 때마다 이 숫자로 나눔.
++추가로 합성수는 즉= 소수들의 곱으로 표현이됨. 그래서 소수들을 미리 구해서 그범위만 순회하면서 나누어 보는 식으로 최적화 시킬 수 도 있음.

*에라토스테네스의 체를 이용한 빠른 소인수분해 알고리즘
에라토스테네스의 체를 변형하여 각 숫자의 가장 작은 소인수를 기록한 다음 그 결과값을 이용해 빠르게 소인수 분해를 수행.->결과값을 이용해 n이 1이 될 때까지 가장 작은 소인수로 나누기를 반복.

-유클리드 알고리즘(Euclidean_algorithm)
두 수의 최대공약수를 구하는 방법으로, 두 수 p,q의 공약수의 집합은 p-q와 q의 공약수 집합과 같다는 점을 이용함.->간단하게 증명이 됌.

*유클리드 알고리즘 구현
int gcd(int p,int q)
{
  if(q==0) return p;
  return gcd(q, p % q);
}

-확장 유클리드 알고리즘(Extended_Euclidean_algorithm)
gcd(p,q)을 수행하는 도중에 출현하는 모든 수는 p,q의 가중치 합인 a*p+b*q으로 쓸 수 있다.
이점을 이용해서 최대 공약수와 함께 a,b를 반환하도록 하는 코드를 추가한 알고리즘

-모듈라 연산(modualr_arithmetic)
모듈로(modulus) M에 도달하면 다시 0으로 돌아가는 정수들을 가지고 하는 연산.
모든 정수는 M으로 나눈 나머지로 표현됌.
덧셈,뺄셈,곱셈에 다음과 같은 성질이 성립됨 -> 쉽게 증명 가능함. 단, 나눗셈은 성립이 안됌.
(a+b)%M=((a%M)+(b%M))%M
(a-b)%M=((a%M)-(b%M)+M)%M
(a+b)%M=((a%M)*(b%M))%M
큰 정수를 계산하는 문제에서 많이 표현됌. ex)결과값을 M으로 나눈 나머지를 출력해라. 등등

++나눗셈의 경우 곱셈 역원을 곱하는 방식으로 이루어진다. a/b는 b로 나누는대신 b의 곱셈역원을 곱한다.(곱셈역원은 항상 존재하는 것이 아닌 b가 M과 서로소 일 때만 존재한다.)   서로소란 최대공약수가 1인 두 수를 의미.
M이 소수일 때 페르마의 소정리를 이용해 곱셈역원을 찾을 수 있다.
소수가 아닌 경우도 디오판틴 방정식을 이용하여 찾을 수 도 있다.
찾으면 다음과 같이 계산할 수 있다.
(a/b)%M=(a*곱셈역원(b,M))%M

-중국인 나머지 정리(Chinese_Remainder_Theorem)
어떤 정수 x가 있을 때, 그 수를 여러 개의 서로소인 수들에 대해 나눈 나머지를 알고 있다면, 그 x를 정확히 하나로 복원할 수 있다 (단, 그 수는 전체 모듈 곱 M에 대해 유일함).

-루카스의 정리(Lucas_Theorem)
모듈라 연산을 이용한 이항 계수를 빠르게 구할 수 있게 해주는 정리
모듈라 연산을 이용하지 않을 경우엔 계산하기 어려울 정도로 큰 n과 r에 대해 이항계수를 계산할 수 있도록 해줌.









