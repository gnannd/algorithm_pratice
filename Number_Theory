정수론에 관련된  가장 기초적인 알고리즘들

-소수(prime_number)
양의 약수가 1과 자기 자신 두 개 뿐인 자연수 -> 반대말로 3개이상 약수를 갖는 자연수를 합성수 라고 한다.
1은 합성수도 아니고 소수도 아님.

*기초적인 소수판별 알고리즘
p*q로 표현되는 자연수 n에 대해 루트n까지 순회하면서 나누어지는지 시도하기.

*에라토스테네스의 체
소수를 찾을 때 마다 그배수들을 지우는 형태로 각 수m이 소수인지 판단하기 위해 루트m까지의 모든 수로 나눠 보는 기초적인 알고리즘에 비해 훨 씬 빠르게 수행됌.
시간복잡도는 거의 O(n)과 비슷하다고 생각하면됌(실제는 어떤 정리에 의해 O(nloglogn)임).
여러 형태로 변형할 수 있기 때문에 여러 정수론 문제를 푸는데 유용하게 사용됌.

-소인수 분해(prime_fac-torization)
합성수를 소수들의 곱으로 표현하는 방법

*기초적인 소인수분해 알고리즘
2부터 시작해 n의 소인수가 될 수 있는 수들을 하나하나 순회하면서 n의 약수를 찾을 때마다 이 숫자로 나눔.
++추가로 합성수는 즉= 소수들의 곱으로 표현이됨. 그래서 소수들을 미리 구해서 그범위만 순회하면서 나누어 보는 식으로 최적화 시킬 수 도 있음.

*에라토스테네스의 체를 이용한 빠른 소인수분해 알고리즘
에라토스테네스의 체를 변형하여 각 숫자의 가장 작은 소인수를 기록한 다음 그 결과값을 이용해 빠르게 소인수 분해를 수행.->결과값을 이용해 n이 1이 될 때까지 가장 작은 소인수로 나누기를 반복.

-유클리드 알고리즘(Euclidean_algorithm)
두 수의 최대공약수를 구하는 방법으로, 두 수 p,q의 공약수의 집합은 p-q와 q의 공약수 집합과 같다는 점을 이용함.->간단하게 증명이 됌.

*유클리드 알고리즘 구현
int gcd(int p,int q)
{
  if(q==0) return p;
  return gcd(q, p % q);
}


-모듈라 연산








