/* kakao blind recruitment 외벽점검
원둘레 길이가 주어지고 길이 사이에 정수로 점검해야할 원소가 주어진다.
그리고 원을 둘레를 덮을 수 있는 길이들이 주어지는데 최소한의 개수를 이용해 길이 사이에 점검해야할 원소들을
다 덮을 수 있어야 하는 문제이다.
근데 덮을 수 있는 길이들이 최대 8개이다.
이점에서 브루트포스로 충분히 풀 수 있다고 생각했고 원둘레도 200이하라 모든 조합을 찾아내 풀면 
시간내에 답을 찾을 수 있을 것이다.

시간복잡도: O(8! * 200 * 200)

밑에 알고리즘만 봐도 모든 조합을 찾기에 답을 찾을 수 있다는것을 쉽게 알 수 있다.
*/

#include <string>
#include <vector>

using namespace std;

void Make(vector<vector<int>>&com,vector<int>&dist,int cnt,vector<int>&im,vector<bool>&check)
{
    if(im.size()==cnt)
        com.push_back(im);
    else
    {
        for(int i=dist.size()-cnt;i<dist.size();i++)
        {
            if(!check[i])
            {
                check[i]=1;
                im.push_back(dist[i]);
                Make(com,dist,cnt,im,check);
                check[i]=0;
                im.pop_back();
            }
        }
    }
}


bool Conbine(int n, const vector<int>&weak,vector<int>&dist,int cnt)
{
    vector<vector<int>>com;
    //순열만들기
    vector<int>im;//임시 저장
    vector<bool>check(dist.size(),0);//중복 방지용
    Make(com,dist,cnt,im,check);
    
    
    bool ok=false;
    for(int i=0;i<com.size();i++)
    {
        for(int j=0;j<weak.size();j++) //weak 원소를 순회하여 답이 될 수 있는 모든 조합을 찾아보기.
        {
            vector<int>weak1;
            int k=j;
            for(int i1=0;i1<weak.size();i1++)
            {
                if(k>=weak.size())
                    weak1.push_back(weak[k%weak.size()]+n);
                else
                    weak1.push_back(weak[k]);
                k+=1;
            }
            
            int start=weak1[0];
            int end=weak1[weak1.size()-1];
            vector<int>vogan(2*n);
            for(int i1=1;i1<weak1.size();i1++)
            {
                for(int j1=weak1[i1-1];j1<weak1[i1];j1++)
                {
                    vogan[j1]=weak1[i1];
                }
            }
            
            for(int r=0;r<com[i].size();r++)
            {
                start+=com[i][r];
                if(start>=end)
                {
                    ok=true;
                    break;
                }
                start=vogan[start];
            }
            if(ok)
                break;
        }
        if(ok)
            break;
    }
    return ok;
}


using namespace std;
//weak는 점검해야할 원소들의 집합 , dist는 덮을 수 있는 길이들의 집합
int solution(int n, vector<int> weak, vector<int> dist) {
    
    int answer = -1;
    for(int i=1;i<=dist.size();i++) //제일 큰 길이부터 쓰는데 개수별로 확인해보기
    {
        //모든 조합 만들어 가능한지 확인.
        bool ok=Conbine(n,weak,dist,i);
        if(ok) //현재 개수로도 모든 원소를 덮을 수 있으면.
        {
            answer=i;
            break;
        }
    }
    
    return answer;
}
