/*백준 1976 여행가자
가중치 없는 무방향그래프가 주어지고 정점N(<200)과 방문해야하는 정점M(<1000)정보가 주어진다.
그리고 방문해야 하는 정점이 주어질때, 방문할 수 있는지 판단하는 문제이다.

그래프 자체가 여러 부분그래프로 주어질 수 있기에, 가능한 모든 경로를 다 탐색해보면 된다.
깊이 우선이든 너비 우선이든 이용해서 가능한 모든 경로를 다 찾아본다음, 방문해야하는 정점을 다 포함하는 경로가 있으면
yes고 없으면 no 출력 하면 된다.

깊이 우선탐색을 이용해 구성하였고, 인접 리스트 방식을 이용하였다.
시간 복잡도는 O(N^2)으로 시간 내 충분히 풀 수 있다.
실제로 시간내에 수행되었고, 주의 할게 두가지 있었다.
예외 두가지를 처리했어야 했는데 1.하나는 M이 0인경우, 2.또 다른 하나는 
방문 도시가 중복해서 주어지는 경우이다.
첫번째는 시작정점의 방문여부를 따져서 부분그래프 탐색을 할 때, 탐색을 했든 안했든
결과 조건을 무조건 검사하는 식으로 해결하였고,
두번째 경우는, 방문해야 할 정점 수로 결과 조건이 만족되는지 따지는 것이 아니라
방문 정점이 방문 되었는지로 for문을 통해 조건을 검사함으로써 해결 되었다.
사실 방문이 가능하면, 중복해서 방문하는 것도 가능하기에, 문제에서 이 예외까지 굳이 포함시켰어야
했나 의문이 들긴했다.

*/

#include <iostream>
#include <vector>

using namespace std;

int main()
{
    int n,m;
    cin>>n>>m;
    vector<vector<int>>graph(n+1);
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=n;j++)
        {
            int k;
            cin>>k;
            if(k==1)
            {
                graph[i].push_back(j);
                graph[j].push_back(i);
            }
        }
    }
    vector<int>check(n+1,0);
    for(int i=0;i<m;i++)
    {
        int num;
        cin>>num;
        check[num]=1;
    }
    vector<int>visit(n+1,0);
    for(int i=1;i<=n;i++)
    {
        vector<int>passed=check;
        if(visit[i]==0)
        {
            visit[i]=1;
            if(passed[i]==1)
            {
                passed[i]=0;
            }
            vector<int>p;
            p.push_back(i);
            while(p.size())
            {
                int vertax=p[p.size()-1];
                p.pop_back();
                for(int j=0;j<graph[vertax].size();j++)
                {
                    if(visit[graph[vertax][j]]==0)
                    {
                        visit[graph[vertax][j]]=1;
                        if(passed[graph[vertax][j]]==1)
                        {
                            passed[graph[vertax][j]]=0;
                        }
                        p.push_back(graph[vertax][j]);
                    }
                }
            }
        }
        bool ok=true;
        for(int j=1;j<=n;j++)
        {
            if(passed[j]==1)
                ok=false;
        }
        if(ok==true)
        {
            cout<<"YES";
            return 0;
        }
    }
    cout<<"NO";
    return 0;
}
