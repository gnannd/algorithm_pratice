/*백준 15681 트리와 쿼리
트리가 주어졌을 때, 정점 U를 루트로하는 서브트리에 속한 정점의 수 출력하는 문제.
정점의 수 N(<10^5), 쿼리의 수Q(<10^5)
간선의 정보가 주어지는데, 그걸로 트리를 구성한다음, 주어진 쿼리에 대해 알맞은 답을 출력하면 된다.
재귀로 간단하게 풀 수 있다.
시간복잡도 O(max(Q,N))   :   트리 구성 O(N) + max(쿼리(Q),트리 순회 O(N))

*/

#include <iostream>
#include <vector>
#include <queue>
#include <string.h>
using namespace std;

int memo[100001];

struct Tree{
    vector<int>node;
};

int GetCnt(int query,vector<Tree>&entire)
{
    int &ret=memo[query];
    if(ret!=-1) return ret;
    ret=1;
    for(int i=0;i<entire[query].node.size();i++)
    {
        ret+=GetCnt(entire[query].node[i],entire);
    }
    
    return ret;
}


int main()
{
    std::ios::sync_with_stdio(false); 
    std::cin.tie(NULL);
    memset(memo,-1,sizeof(memo));
    int n,root,r;
    cin>>n>>root>>r;
    vector<vector<int>>edge(n+1);
    for(int i=0;i<n-1;i++)
    {
        int a,b;
        cin>>a>>b;
        edge[a].push_back(b);
        edge[b].push_back(a);
    }
    vector<int>visit(n+1);
    vector<Tree>entire(n+1);
    visit[root]=1;
    queue<int>get_tree;
    get_tree.push(root);
    while(!get_tree.empty())
    {
        int k=get_tree.front();
        get_tree.pop();
        for(int i=0;i<edge[k].size();i++)
        {
            if(visit[edge[k][i]]!=1)
            {
                visit[edge[k][i]]=1;
                get_tree.push(edge[k][i]);
                entire[k].node.push_back(edge[k][i]);
            }
        }
    }
    
    
    for(int i=0;i<r;i++)
    {
        int query;
        cin>>query;
        cout<<GetCnt(query,entire)<<'\n';    
    }
    
    return 0;
}
