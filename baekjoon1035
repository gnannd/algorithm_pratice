/*백준 1035
5*5 보드에 조각이 있고 그조각들을 상하좌우 한칸씩 움직여 다연결 되게 해라.
이때 움직인 횟수를 최소화 해라. (조각의 개수는 5이하 자연수이다.)
이문제는 다이나믹으로도 풀 수 있고 그래프 탐색으로도 풀 수 있다고 봤다.
보드의 상태를 활용하여야 하는건 둘 다 똑같기 떄문에 이 문제 탐색 과정상 그래프 탐색을 이용해
풀기로 했고 보드가 5*5이 기 때문에 int 비트마스킹을 이용하여 상태를 표현하기로 했다.

구현해야 할 연산은 두가지이다.
1.그래프 탐색 과정 ->보드상태를 현재상태로 둔다. 비트마스킹 이용 2^(25)<int자료형 범위
2.현재 조각이 다연결 되었는지.
3.보드 상태를 int 표현 ->비트마스킹 구현.
시간복잡도: O(5*5*(조각의개수*4)) 조각의 개수가 5이하 자연수로 시간내에 충분히 풀 수 있다.
-> 사실 정확히 따지기엔 값이 상수고 너무 작아 저정도 되니까 알고리즘에 문제는 없다고 생각하면 될듯.
메모리: 보드상태를 저장하는 공간이 2^25이 필요한데. 메모리 제한 512MB이라 공간이 충분하다.

구현이 많고 복잡할 뿐이지, 발상 자체는 쉬웠다.
구현이 복잡하고 연산할게 많다 보니 실제 수행시간이랑 메모리가 예상한거보다 10배정도는 더 나왔다.
메모리: 약130MB, 시간: 약100ms
그래도 시간내에 통과하였다.
*/

#include <iostream>
#include <vector>

using namespace std;

int dy[4]={0,1,-1,0};
int dx[4]={1,0,0,-1};

int TransInt(vector<vector<int>>&board) //보드 상태를 int로 표현.
{
    int th=0;
    int num=0;
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<5;j++)
        {
            if(board[i][j]==1)
            {
                num|=1<<th;
            }
            th+=1;
        }
    }
    return num;
}

bool Checking(vector<vector<int>>&board,int cnt)
{
    for(int i=0;i<5;i++)
    {
        for(int j=0;j<5;j++)
        {
            if(board[i][j]==1)
            {
                cnt-=1;
                vector<vector<int>>visit(5,vector<int>(5));//이건 오로지 이어져있는지 탐색을 위한 증벅빙지용 
                visit[i][j]=1;
                vector<vector<int>>st;
                vector<int>temp(2);
                temp[0]=i,temp[1]=j;
                st.push_back(temp);
                while(st.size()) //확인이기 때문에 깊이 탐색이든 너비탐색이든 상관없음.
                {
                    int y=st[st.size()-1][0];
                    int x=st[st.size()-1][1];
                    st.pop_back();
                    for(int r=0;r<4;r++)
                    {
                        if((y+dy[r] >= 0) and (y+dy[r] <5) and (x+dx[r]>=0) and (x+dx[r]<5))
                        {
                            if(board[y+dy[r]][x+dx[r]]==1 and visit[y+dy[r]][x+dx[r]]==0)
                            {
                                vector<int>p(2);
                                p[0]=y+dy[r];
                                p[1]=x+dx[r];
                                st.push_back(p);
                                visit[y+dy[r]][x+dx[r]]=1;
                                cnt-=1;
                            }
                        }
                    }
                }

                if(cnt!=0) 
                    return false;
                return true;
            }
        }
    }
    return true;
}

int main()
{
    int cnt=0;
    vector<vector<int>>board(5,vector<int>(5));
    vector<int>visit(1<<25,-1);   //중복 방지 + 몇번 이동했는지 정보까지 담기.
    //탐색은 너비탐색으로 해야 최소를 구할 수 있음.
    vector<int>order;
    for(int i=0;i<5;i++)
    {
        string s;
        cin>>s;
        for(int j=0;j<5;j++)
        {
            if(s[j]=='*')
            {
                board[i][j]=1;
                cnt+=1;
            }
            else{
                board[i][j]=0;
            }
        }
    }
    
    visit[TransInt(board)]=0;
    order.push_back(TransInt(board));
    //queue로 너비 탐색 구현할 수 있지만 그냥 vector 구현함. 라이브러리 불러오는것도 일이기 때문에.
    //대신 pop을 하는게 아니다 보니 메모리를 많이 잡어먹게 되긴함.
    //실제 수행하는거 생각해 보면 그정도 까지 아닐거라는게 어림짐작 됌.
    int pos=0;
    while(pos!=order.size())
    {
        int val=order[pos];
        pos+=1;
        //int 를 다시 보드로 구현 여기에만 쓸꺼라 따로 함수처리는 안했음.
        vector<vector<int>>p_board(5,vector<int>(5,0));
        int num=0;
        for(int i=0;i<5;i++)
        {
            for(int j=0;j<5;j++)
            {
                if(((1<<num)&val)!=0)
                    p_board[i][j]=1;
                num+=1;
            }
        }
        
        
        if(Checking(p_board,cnt)) // 조건이 완료 되면 break 최소값출력 -> 여길 먼저 들어오는 얘가 제일 작은 결과값임.
        {
            cout<<visit[val];
            break;
        }
        
        //너비 탐색.
        for(int i=0;i<5;i++)
        {
            for(int j=0;j<5;j++)
            {
                if(p_board[i][j]==1)
                {
                    for(int r=0;r<4;r++)
                    {
                        if((i+dy[r] >= 0) and (i+dy[r] <5) and (j+dx[r]>=0) and (j+dx[r]<5))
                        {
                            int next=val-(1<<(5*i+j));
                            next|=1<<(5*(i+dy[r])+j+dx[r]);
                            if(p_board[i+dy[r]][j+dx[r]]==0 and visit[next]==-1)
                            {
                                visit[next]=visit[val]+1;
                                order.push_back(next);
                            }
                        }
                    }
                }
            }
            
        }
    }
    
    return 0;
}
