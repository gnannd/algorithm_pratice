/*백준 1414 불우이웃돕기
N개의 컴퓨터가 주어지고 서로를 연결하는 선의 길이가 주어질 떄, 모든 컴퓨터들 끼리 연결되어야 
하고 최소 연결 길이합을 구하는 문제이다. (N은 50이하)

이거 그리디 방법을 생각해볼수 있다.
모든 길이를 다 모놓아놓고 정렬한 다음 제일 작은 길이부터 넣되 사이클이 안생기도록 한다.
그런식으로 모든 컴퓨터들이 연결 될 때가지 길이를 추가한다. 
작은 길이부터 추가 -> 사이클 확인(생기면 다음길이로 넘어감) or 모두 연결됐는지 확인(확인 되면 종료) -> 모든 컴퓨터가 연결될 때 까지 추가.

증명 - 이것이 왜 최적의 답안으로 흘러가나.
사이클이 생긴다는것은 최적의 답안이 아닌것-> 결국 최종 답안은 사이클이 없는 그래프 임.->길이개수가 N-1개.
만약 답들중에 제안된 방식이 아닌 방식의 답(N-1개인데 다른 답)이 있다고 가정하면 그 답을 길이 작은순을 정렬하면 우리가
제안한 방식의 답임. 여러가지 예외적인 경우를 생각할려고 해도 우리가 제안한 방식으로 무조건 답이 나오게 되어있음.
이 제안된 방식은 모두 연결이 될 때까지 모든 길이에 대해 차례로 추가하기 때문에 모두 연결할 수 없다는 것은
애초에 어떠한 방식으로도 연결할 수 없는 거임.(마지막에 가면 모든길이에 대해 중복을 제외하고 다 추가하기 때문.)

예를 좀들자면, 제안된 방식에 포함된 아닌 답이 있다  x라는 값을 제안된 방식중 어떠한 것과 대체가 된다라고 하면 
x가 교체 됐을 때 연결 길이 합이 더 줄어져야 한다. 
x가 어떤 값이 되든 작든 뭐보다 크고 뭐보다 작든 우리가 제안된 방식으로 돌아오게 된다. 애초에 x가 들어갔어야 했으면
이미 제안된 방식에 포함되어 있다. N-1개를 유지해야 하기 때문에 x가 들어가고 어떤 값들(2개이상)이 빠져야 되는 경우도 안되고
어떤 경우도 안됌. 결국 우리가 제안한 방식이 귀류법으로 증명이됌.

최소길이 추가랑, 사이클이 있는지 확인하는거(탐색) = N*N=N^2 
시간복잡도 : O(N^2) N이 50이하라 충분히 시간내에 수행가능하다.
예외케이스가 많아 구현이 복잡했다. 그리고 찾아보니 이런 사이클없는 최단 거리합 그래프를 만드는 알고리즘을 스패닝트리 알고리즘이라고 한다.
실제 시간도 거의 0ms로 수행되었다.
*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;
bool succes=false;
bool Cicle(vector<vector<int>>&shot,int start)
{
    if(succes) return true;
    bool ok=false;
    int cnt=1;
    
    vector<int>visit(shot.size(),-2); //어디로 부터 방문됐는지.
    vector<int>que;
    
    que.push_back(start);
    visit[start]=-1;
    while(que.size())
    {
        int next=que[que.size()-1]; //현재 방문 지점.
        que.pop_back();
        for(int i=0;i<shot[next].size();i++) // 다음 방문 지점
        {
            if(shot[next][i]!=0 and i!=visit[next]) //길이 연결되어있고 , 전에 왔던 곳이 아닌.
            {
                if(visit[i]!=-2)
                    ok=true;
                else
                {
                    visit[i]=next;
                    que.push_back(i);
                    cnt+=1;
                    if(cnt==shot.size())
                        succes=true;
                }
            }
        }
        if(ok)
            break;
    }
    return ok;
}
int main()
{
    int N;
    cin>>N;
    
    vector<vector<int>>graph;  //길이, A , B
    for(int i=0;i<N;i++) //모든 길이 추출 
    {
        vector<int>len(3);
        len[1]=i;
        string s;
        cin>>s;
        for(int j=0;j<N;j++)
        {
            if(s[j]>='a' and s[j]<='z')
            {
                len[0]=s[j]-'a'+1;
                len[2]=j;
                graph.push_back(len);
            }
            else if(s[j]>='A' and s[j]<='Z')
            {
                len[0]=s[j]-'A'+27;
                len[2]=j;
                graph.push_back(len);
            }
        }
    }
    
    
    sort(graph.begin(),graph.end(),less<vector<int>>());
    
    
    int answer=0; //답이 int범위를 벗아나지 않음 최대 개수 2500개에 최대값 52이라 백만도 안됌. 나올 수 있는 값이.
    vector<vector<int>>shot(N,vector<int>(N,0)); // 하나씩 추가할 텐데 i , j 연결상태
    for(int i=0;i<graph.size();i++)
    {
        shot[graph[i][1]][graph[i][2]]+=1;
        shot[graph[i][2]][graph[i][1]]+=1;
        if(shot[graph[i][1]][graph[i][2]]>=2 or Cicle(shot,graph[i][1])) //추가했는데 사이클이 생기면 넘어감.
        {
            shot[graph[i][1]][graph[i][2]]-=1;
            shot[graph[i][2]][graph[i][1]]-=1;
            answer+=graph[i][0];
            continue;
        }
    }
    if(succes or N==1)  //예외케이스도 추가 N이 1인경우
        cout<<answer;
    else
        cout<<-1;    
    return 0;
}
