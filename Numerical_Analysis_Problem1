/*백준 31532 선형 회귀는 너무쉬워3
(yi-axi-b)^3 을 0에 가장가깝하는 실수 a를 구하는 문제이다. xi들은 양의정수들로만 주어지고,
yi실제값들은 정수로만 주어진다. 상대,절대오차가 10의-7승까지 허용.
n개 xi,yi가 주어진다.(n은 10의 5승 이하)

이 문제는 수치해석의 선형회귀에 관한 문제로 
a값에 따른 오차가 최소화 되게 하는 a값을 구하는건데 
결국 함수 f(x)=오차 0이되게하는 값을 찾는 rooting problem이랑 똑같은 문제이다.
평균값 정리를 이용해서 bisection 이분탐색을 하면 값을 구할 수 있다.
초기값 설정만 구간내에 값이 존재할 수 있도록 잘고르면 되는데 
값이 조건들을 보아 a1=200001이면 무조건 음수가 나오고
a2=-200001이면 무조건 양수가 나온다. 이것을 초기 구간을 잡고 풀었다.
n이 10만이하라 오차값을 구하는 함수 연산이 10만 이하 정도 나올거고
bisection에 관해 2의거듭제곱승 꼴로 구간이 줄어드니까 100번정도면 충분히 값을 찾고 남을것이다.
그래서 시간복잡도는 O(10만 * 100) 정도 예상된다.
실제 수행시간은 약 700ms 로 통과되었지만, 생각보다 오래걸린 것을 알 수 있는데
실수연산이 값이 크고 많다 보니 많은 연산량으로 인한 처리속도 감소가 원인으로 보인다.
*/

#include <iostream>
#include <cmath>
using namespace std;
int n,b;
int pre[100000][2];

double f(double a)
{
    double save=0;
    for(int i=0;i<n;i++)
    {
        save+=pow(pre[i][1]-a*pre[i][0]-b,3);
    }
    return save;
}


int main()
{
    cout.precision(7);
    cout << fixed;
    cin>>n>>b;
    double a1=2000001,a2=-2000001;
    for(int i=0;i<n;i++)
        cin>>pre[i][0]>>pre[i][1];
    while(abs(a2-a1)>1e-7)
    {
        double mid=(a2+a1)/2;
        if(f(mid)<=0 and f(a1)<=0)
        {
            a1=mid;
        }
        else
        {
            a2=mid;
        }
    }
    cout<<(a2+a1)/2;
    return 0;
}
