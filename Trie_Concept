문자열의 집합을 표현하는 트리 자료구조.
보통 원소가 정수나 실수면 비교에 상수시간이 걸리지만, 문자열의 경우 문자열 크기에 비례하는 시간이 걸린다.
그래서 원하는 원소를 찾는 작업을 할때, 이진검색트리를 이용해 탐색을 lgn에 한다고 하여도 비교에 문자열 크기 M에 비례해 Mlgn이 걸리게 된다. 
하지만, Trie는 원소를 찾는 작업을 O(M)에 할 수 있게 한다.
표현은 집합 원소들(문자열)의 접두사를 부모로 하게 하여, 아래로 내려갈수록 크기가 1씩 늘어나게 하는 구조이다. ex) trie이면 부모가 tri 그 부모가 tr 그 부모가 t, 루트노드는 공백
그래서 한노드까지 내려가는 경로의 글자들을 모으면 해당노드에 대응되는 접두사들을 얻을 수 있다.
그리고 종료노드라고 부르는 노드들은 문자열 집합에 포함되는 글자들로 각 노드들은 종료노드인지를 나타내는 불린값을 가진다.
++그렇다고 문자열을을 찾을 때 종료노드인지를 확인해서 찾진않고, 문자열의 접두사들을(노드)를 따라가서 찾기 때문에 문자열집합의 원소가 아니고 해당문자열의 접두사라도 찾을 수 있다. 
또 각노드들은 자식포인터 배열을가지는 데 배열의 크기는 나올 수 있는 모든 문자의 크기이다. ex)알파벳 대문자로만 문자열이 구성된다고 하면, 포인터배열의 크기는 26이다.

문제는, 메모리를 많이 쓴다는 점이다. 모든 문자열이 서로겹치는 문자가 없으면 문자열의 총합길이에 비례하기 때문인데, 이걸 최적화(Ex, 트리플 어레이 트라이) 할 수는 있지만, 대회에서는 시간이 오래걸리기 때문에
보통 문자열의 개수가 많지 않는 경우로 제한된다.

문자열의 부분문자열을 빠르게 찾아내기 위해 모든 접미사를 트라이에 넣어 이용하기도 한다.-> 부분문자열은 어떤 접미사의 접두사이기 때문에. 근데 성능면이나 구현 복잡성 때문에 대회에서 잘안씀.
