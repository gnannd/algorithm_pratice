/*백준 1508 레이스
수직선 상 길이 N이 있고 M개의 위치에 K개의 심판을 배치 한다고 할 때, 가장 가까운 두 심판의 
거리가 최대가 하는데 배치를 출력해라. 여러개 있는 경우우 사전순으로 가장 늦는 것을 출력
N은 백만 이하, M,K 50 이하 자연수이다.

이 문제를 보고 모든 탐색을 고려해보는 브루트포스나 효율적으로 모든 탐색을 고려하는 다이나믹 
둘다 쓰기에는 제한이 있다. (N,M,K 최대 값을 고려해보면. 그리고 다이나믹은 최적 부분구조가 성립이 안됌)
이러면 또 그리디 가 떠오르는데 매선택마다 모든 경우를 고려하지 않고 정의한 매커니즘 대로 최적의 선택이
최종 최적의 선택이 된다는 걸 증명만 하면 빠른 시간내에 풀 수 있을 것 같았다.

제일 먼저 떠올랐던건 맨 앞위치는 무조건 선택하는 것이다. 아닌 최적해가 있다고 가정해도 맨 앞 심판을 맨 앞위치로 옮길 수 
있어 무조건 맨앞위치는 포함하게 된다. 그리고 사전 순 늦는걸 출력해야 하기 때문에 맨앞위치는 무조건 선택해야 한다.

내가 생각해낸 방식은 나올 수 있는 가장 가까운 두심판의 거리 값들을 모두 고려해 보는것이다.
그리고 그값들을 내림차순하여 순서대로 만들 수 있는지 그리디로 테스트 해보고 만들 수 있다면 출력하는 것이다.
일단 나올수 있는 모든 거리를 생각해 보기 때문에 그중에 정답이 있을 것이고, 모든 거리 값들을 만드는데
데 드는 시간이 KC2로 굉장히 작다.
그리고 내림차순을 통해 두심판의 거리를 최대로 하는 조건을 만족시킬것이다. 
그리고 각 거리에 대해 되는지 테스트를 할 때, 이전위치 기준(처음엔 맨 앞위치) 그다음 위치 중 distance이상 가장 가까운 위치를 
순서대로 잡아가며 되는지 본다. -> 그러면 사전상 제일 늦는것을 출력 부분도 만족 시키게 된다.

시간 복잡도: O(K * KC2)로 K가 50이하 자연수로 생각하면 약 125000이하로 시간내에 충분히 풀 수 있다.

참고로 각 거리에 대해 테스트 할 때 거리이상 가장 가까운 위치를 계속 잡아가는 이 그리디 해법에 대해 
증명을 따로 하지않겠다. 너무 직관적으로도 보이고 자명하다. (거리이상 위치 선택 중,그냥 다른 선택의 답이 있다고 가정하면 
그 위치를 앞으로 당겨 오는 것 또한 답이 되기 때문에, 더하여 사전순 까지 생각하면 다른 선택의 답은 해가 될 수 없음.)
증명을 해버린거 같지만..

치명적 실수..  이렇게 answer.size()를 for문 조건에 넣었는데 동작이 answer에 값을 추가하는것이었다.
answer에 값이 추가가 되면서 answer.size()의 값 또한 변해서 내가 원하는 값이 나오지 않아 헤멨었다.
for문 조건에 고정 값이라고 생각하고 넣은 내 실수였다. -> 다른 변수로 값을 받아 고정값으로 대체했다.

실수 코드 
for(int i= ; i< answer.size())  
    answer+="뭐시기"
*/

#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
    int N,M,K;
    cin>>N>>M>>K;
    
    vector<int>number(K); 
    vector<int>dis; // 모든 거리 고려.
    
    for(int i=0;i<K;i++)
        cin>>number[i];
        
    for(int i=0;i<K-1;i++) //나올 수 있는 모든 거리에 대해 뽑겠다.
        for(int j=i+1;j<K;j++)
            dis.push_back(number[j]-number[i]);
    
    if(K<2){ //예외처리
        cout<<1;
        return 0;
    }
    
    sort(dis.begin(),dis.end(),greater<int>());
    for(int i=0;i<dis.size();i++)
    {
        int cnt=M-1;
        int distance=dis[i];
        string answer="1";
        int before=number[0];
        int j=1;
        while(j!=number.size())
        {
            
            if(number[j]-before>=distance)
            {
                answer+="1";
                before=number[j];
                j+=1;
                cnt-=1;
            }
            else
            {
                answer+="0";
                j+=1;
                
            }
            if(cnt==0)
            {
                break;
            }
        }
        if(cnt==0)
        {
            if(answer.size()!=K)
            {
                int siz=answer.size(); //answer.size은 값이 변하기에 siz에 담아  for문 조건에 넣음.
                for(int r=0;r<K-siz;r++)
                {
                    answer=answer+"0";
                }
            }
            cout<<answer;
            break;
        }
    }

    return 0;
}
