/*
백준 13164번
일렬로 세워진 정수를 k개의 부분집합으로 만들 돼 부분집합안에 원소끼리는 서로 인접해 있어야한다.
이때 각조에 가장 큰 정수와 가장 작은 정수의 차 만큼 비용이 발생하고 우리는 비용의 합을 최소화 해야 한다.
N<=300,000

처음에 모든 조합을 고려 하는 브루트 포스를 생각 해 봤고 N이 30만이므로 모든 조합을 고려하기엔 수행시간이 턱없이 부족했다. NCk
더하여 남은 인원과 남은 k의 조의 입력을 받아 메모이제이션 하는 다이나믹 또한 생각해 봤지만 이것 또한 수행시간이 턱없이 부족했다. N^3

값이 정렬 되어 있기 때문에  각 조의 비용의 합은 각 조의 인접한 애들의 차이의 합이라는 걸 알 수 있다. 이 차이의 합을 최소화 하기 위해선 
차이가 제일 벌어지게 되는 부분을 기준으로 조를 나누면 된다. 즉, 차이가 큰 부분을 조로 나누게 해 차이 만큼 비용의 값을 최소화 하는거다.
그래서 인접한 수들의 차이를 구한다음 큰 순으로 정렬하여 k-1 개만큼 전체 차이를 다더한 비용(전체가 한조 면 제일 끝값과 처음값의 차이)에서 빼주면 된다. 
시간복잡도도 O(nlgn)정렬 시간만큼 들기 때문에 충분히 시간안에 구현이 된다.

각 조의 비용의 합이 각 조의 인접한 애들의 차이의 합이라는걸 알면 증명안해도 이게 최적해를 구하는 방법이라는 걸 쉽게 알 수 있다.
왜냐면 아니라는 최적해가 있다해도 내가 제안한 방식 대로 바꾼다면(차이가 제일 큰 부분을 조로 만드는걸로 바꿔도) 비용이 최소화 되면 됐지 안좋아지지는 않기 때문이다.

실제로 시간안에 충분히 수행되었다.

*/
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main()
{
    int n,k;
    cin>>n>>k;
    int cost=0;
    vector<int>number(n);
    for(int i=0;i<n;i++)
    {
        cin>>number[i];
    }
    vector<int>p(n-1);
    for(int i=0;i<n-1;i++)
    {
        p[i]=number[i+1]-number[i];
        cost+=p[i];
    }
    
    sort(p.begin(),p.end(),greater<int>());
    
    for(int i=0;i<k-1;i++)
        cost-=p[i];
    cout<<cost;
    return 0;
}
