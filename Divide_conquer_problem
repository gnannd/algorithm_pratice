//백즌 1030 프렉탈 평면
// 무식한 방법으로는 전체 다 표현해서 배열에 저장한뒤 출력해야하는 부분만 출력-> 대충 계산해도 시간초과
// 다 표현하지 않고 필요한 부분만 바로바로 출력 해야함. -> 조건을 보면 출력해야 하는 부분이  가로, 세로 50으로 제한 
//내가 출력해야하는 부분을 다 돌면서 검은색인지 흰색인지 바로바로 출력
// 시간 복잡도는  O(s*(r2-r1)*(c2-c1))        최대깊이 10 * 출력최대크기(50*50)= 25000 

//처음에 분할하고 하나하나 병합하는 과정을 생각했었는데, 병합하는 과정이 까다로웠다. 근데 생각해보니 출력해야 부분이 매우작았고 하나하나 검은색인지 
//흰색인지 탐색해도 충분했었다. 그리고 탐색하는 과정 전에 n,k값을 통해 검은색이 나오는 부분의 영역을 미리 표시하니 코드값이 매우 간단하게 작성되었다.
//분할정복이 주라긴 보단 구현문제에 분할이 사용된 느낌. 
//n*n 영역에서 n,k 값을 이용해 쪼개 검은구간 영역들을 미리 표시했다. 그리고 검은색인지 흰색인지 탐색하는 과정에서는 s값에따라 맞게 영역의 크기를
//조절하면서 미리 표시했던 구간들을 통해 검은 영역인지 아닌지 확인했고 아니면 다시 재귀를 통해 s-1 하면서 i,j 값도 그 값에 따라 맞췄다. 

#include <iostream>
#include <vector>
#include <cmath>

using namespace std;
int s, n, k, r1, r2, c1, c2; //편의를 위해

int get_number(int s,int i,int j,vector<vector<int>>&area)
{
    if(s==0)//검정영역이 아니면.
        return 0;
    
        
    //아닌 부분은 재귀.
    //사실상 검은영역 부분에 들어가는지만 확인 하면 됌.
    int p=pow(n,s-1);
    if(area[i/p][j/p]==1)
        return 1;
    return get_number(s-1,i%p,j%p,area);
    
    
}

int main()
{
    cin>>s>>n>>k>>r1>>r2>>c1>>c2;
    
    vector<vector<int>>area(n,vector<int>(n));

    //미리 검은영역인 곳들을 표시.
    for(int i=0;i<k;i++) //k가 짝수든 홀수든 똑같음.
    {
        for(int j=0;j<k;j++)
            area[n/2-k/2+i][n/2-k/2+j]=1;
    }
    
    for(int i=r1;i<=r2;i++)
    {
        for(int j=c1;j<=c2;j++)
        {
            cout<<get_number(s,i,j,area);
        }
        cout<<'\n';
    }
    return 0;
}
