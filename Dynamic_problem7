//2637 장난감 조립
/*
여러 기본부품과 그 기본부품의 조합들로 만들어지는 중간부품, 그리고 두 종류의 부품을 이용해 최종부품을 만드는 문제로
필요한 기본부품의 종류와 수를 출력해야 한다.
두 중간 부품이 서로를 필요로 하는 경우가 없다. -> 말도 안되는건 없다.

쉽게 바로 떠올를수 있는건 재귀를 이용해 최종 부품에서 계속 분해해 나가는것이다.
이때 중복 될 수 있는 중간부품은 한번만 구해지도록 메모이제이션 하면 되는 것으로 보인다.
더하여 값을 저장할 때 필요한 부품의 종류와 개수를 저장해야 하는데 
이부분을 배열을 이용하는 것보다 비트마스킹을 이용하면 쉽게 구현 할 수 있을것이라고 생각했다.
-> 하지만 종류와 개수 상한선을 고려했을 때 배열을 이용하는게 좀 더 편한거 같아서 배열을 이용했다.

++정답이 int 변수 범위 안이라고 표기 되어 있어 int 자료형 사용하는데 문제가 없다.

시간복잡도는 대략  입력 상태의 수 N * 시행횟수(최대 100*100) 충분히 시간안에 풀 수 있을 것이다. 
*/
#include <iostream>
#include <vector>

using namespace std;

vector<vector<int>>state(101,vector<int>(101,0));

vector<int> Part_Count(int target,vector<vector<int>>&need_part,vector<int>&check)
{
    if(check[target]==0) return need_part[target];
    
    if(state[target][100]!=-1) return state[target];
    
    state[target][100]=0; // 이미 값을 찾았다는것을 표시. 메모이제이션 중복방지. 0으로 표기한건 나중에 값을 구하는데 차질이 없게 하기 위해.
    
    for(int i=0;i<need_part[target].size();i++) //필요한 부품들 찾기.
    {
        if(need_part[target][i]!=0) //부품번호 i에 개수가 주어지면
        {
            vector<int>make=Part_Count(i,need_part,check); //그번호의 부품 종류 수 구하기
            for(int j=0;j<make.size();j++)
            {
                state[target][j]+=need_part[target][i]*make[j];
            }
        }
    }
    
    return state[target];
    
}

int main()
{
    for(int i=0;i<101;i++)
        state[i][100]=-1;  //메모이제이션을 위한 초기화 
    
    int n=0,m=0;
    cin>>n>>m;
    
    
    vector<vector<int>>need_part(n+1,vector<int>(n,0));
    vector<int>check(n+1,0); // 기본부품 체크
    for(int i=0;i<m;i++)
    {
        int target=0, part=0, cnt=0;
        cin>>target>>part>>cnt;
        need_part[target][part]=cnt;
        check[target]=1;
    }
    
    for(int i=0;i<n+1;i++)
    {
        if(check[i]==0) //기본부품이면.
            need_part[i][i]=1;
    }
    
    
    vector<int>answer=Part_Count(n,need_part,check);
    
    for(int i=0;i<n;i++)
    {
        if(answer[i]!=0)
        {
            cout<<i<<' '<<answer[i]<<'\n';
        }
    }
    
    
    return 0;
}
