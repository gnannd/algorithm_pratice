/*백준 1039 교환 
N,K 가 주어지고 정수 N에 대해 K번 자리 바꿔 만들 수 있는 제일 큰수를 출력하는것.(N은 백만 이하 자연수수, K 10 이하 자연수)
숫자가 0으로 시작할 수 는 없기에 k번 연산이 불가능한 경우 -1를 출력 하여야 한다.
여기서 불가능한 경우
1.바꿀 수 있는 자리가 없는 경우 예를 들어 n이 한자릿수 숫자인 경우 연산자체가 불가. -> 예외 처리 N이 한자리면 -1 출력.
2.바꿨을 때 앞자리에 0이 오는 경우  -> 탐색할 때 앞자리에 0이 올 것 같은 애들은 거르면 됌.

!!!여기서 부터 잘못생각함.
N이 백만이하인데 탐색은 자릿수에 따르기 때문에 10이하 이다. 여기서 드는 생각이
모든 탐색을 해도 되지만 N이 백만이하 라 브루트 포스는 무조건 시간내에 풀 수 없다는 걸 알 수 있다. (한번 연산하는데만 백만 ^2 이 걸리는 걸 알 수 있음.)

그럼 다이나믹을 생각해 볼 수 있는데 상태의수가 N,k 탐색이 (N의 자릿 수 ^ 2)  그럼 O(n*k*(7^2)) 대충 한 이정도 걸리는데 이것도 주어진 2초내에 
풀기에는 조금 버거운 감이 있다.

잘 생각해보면 제일 큰값은 앞자리가 제일 큰 값이 올 수 있으면 와야 한다는 당연한 사실이 있다. 즉 매 연산마다 앞자리에 제일 큰 값이 순서대로 오게끔.
선택하면 될 거라 생각했다.
그리고 우리는 연산의 매선택마다 다음과 같은 논리로 접근 하면 답을 찾을 수 있을 것같다.
1. 앞자리에 제일 큰 값 순서대로 오게끔 위치를 바꾼다. 
2. 이런식으로 연산 횟수 내 만들 수 있는 제일 큰 값을 찾는다.
3. 만약 연산횟수가 남는다면 값을 변화 시키지않고 연산횟수를 다 소진 시킬 수 있는지 확인한다.(중복 숫자가 있는 경우,k가 홀 수번 남은 경우)
4. 값이 변할 수 밖에 없다면 맨 뒷자리 두숫자를 바꾸는 것으로 연산횟수를 다소진 시킨다.
5. 근데 불가능한 경우 앞자리가 0이 온다는 것은. 20,30 이런 숫자들 밖에 없으므로 -1 출력 시킨다. -> N이 10 하 예외처리 처럼 같이 예외처리 하면 됌.
10이하 숫자들은 예외처리로 코드 로직을 쉽게 구현 할 수 있게끔한다.


시간복잡도: O(n의 자릿수 ^2) 진짜 짧은 시간내에 수행할 수 있음. 

이문제는 그리디 문제로 매선택에 최적의 선택을 할 수 있는 해법이 있어 굉장히 빠른 알고리즘으로 문제를 풀 수 있었다.
문제는 쉬운데 구현 자체에 까다로운 문제였다. 생각하고 신경써줘야 할 부분들이 많았다. 
++ 그리고 놓친 부분이 있었는데 큰 값이 오게 값을 바꿀 때 같은 값이 존재하면 뒤에 있는 얘를 택해야 한다. 그래야 값이 제일 커짐.


!!!잘못생각한걸 깨닫고 난 후후~~
이렇게 생각을 했는데.. 이 중복값이 있으면 선택이 까다로워 진다.. 매선택이 최적이라고 확정 지을 수 없게 된다.
예로 213444 3 이렇게 주어지면 4값이 맨뒤부터 앞자리로 오게되는데 중복값이라 앞자리에 뭐랑 바꾸냐에 따라 값이 달라져서 
탐색을 하긴 해야함. 그래도 이부분만 고려해서 코드를 짜면 대충 7의 7승으로 천만이하의 연산량이 나와서 시간내에 풀 수 있기는 한다.
그리고 왜그랬는지는 모르겠는데 브루트포스 시간 계산을 잘못 측정 했다. 이문제는 브루트 포스로 충분히 풀 수 있다. 
시간 복잡도: O(n의 자릿수 ^ n의 자릿 수 * n의 자릿 수) 약 천만이하여서 시간 내에 풀 수 있을 것으로 보인다.

생각을 너무 많이 해서 오래걸렸다. 쉽게 차근차근 생각했어야 했는데 급하게 쓸데없는데 많이 생각했던거 같다.
브루트포스에 대해서 다시 공부해야겠다.
*/
#include <iostream>
#include <vector>

using namespace std;

bool ck=false;

int value(vector<int>&reverse_num)
{
    if(reverse_num[reverse_num.size()-1]==0)
        return -1;
    int val=0;
    for(int i=reverse_num.size()-1;i>=0;i--)
    {
        val*=10;
        val+=reverse_num[i];
    }
    return val;
}

int Make(vector<int>reverse_num,int k,int size)
{
    if(k==0)
    {
        return value(reverse_num);
    }
    if(size==0)
    {
        if(ck==true or (k%2==0))
        {
            return value(reverse_num);
        }
        return -1;
    }
    int max1=Make(reverse_num,k,size-1); //앞자리 안바꾸기.
    int temp=0;
    for(int i=size-1;i>=0;i--)
    {
        temp=reverse_num[size];
        reverse_num[size]=reverse_num[i];
        reverse_num[i]=temp;
        max1=max(max1,Make(reverse_num,k-1,size-1));
        temp=reverse_num[size];
        reverse_num[size]=reverse_num[i];
        reverse_num[i]=temp;
    }
    return max1;
}

int main()
{
    int N,K;
    
    cin>>N>>K;
    vector<int>check(10);
    
    if(N<=10 or (N<100 and N%10==0)){ //N이 10이하거나 두자릿수 10의 배수들은  애초에 연산자체가 불가 하기에 예외처리
        cout<<-1;
        return 0;
    }
    
    vector<int>reverse_num;  //탐색 편의를 위해 벡터에 값을 저장. 근데 거꾸로 저장.
    while(N!=0)
    {
        check[N%10]+=1;
        if(check[N%10]>1)
            ck=true;
        reverse_num.push_back(N%10);
        N/=10;
    }
    
    cout<<Make(reverse_num,K,reverse_num.size()-1);

    return 0;
}
