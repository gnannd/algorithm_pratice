/*백준 1890
n*n 게임판이 주어지고 맨 왼쪽 위 에서 맨 오른쪽아래로 갈 수 있는 경로의 개수를 구하는 문제
게임판에 내가 있는 위치를 입력 상태로 받아 맨 오른쪽 아래로 갈 수 있는 경로의 개수를 구하게 하여 푸는
전형적인 다이나믹 문제.
n이 100 이하 이므로 다이나믹으로 풀면 시간 내에 풀 수 있다.
시간복잡도 O(N^2) - 입력의 상태수 N*N
근데 나올 수 있는 경로의 개수가 2^63-1 이하이므로 int 자료형으로는 범위가 넘어가기에 long long 자료형을 썼다.

실제로 0ms로 빠른 시간내에 수행되었다.
*/

#include <iostream>
#include <vector>
#include <string.h>
#include <vector>

using namespace std;

long long memo[100][100];

long long GetCnt(vector<vector<int>>&game,int x,int y)
{
    if(x==(game.size()-1) and y==(game.size()-1))
        return 1;
    long long &ret=memo[y][x];
    if(ret!=-1) return ret;
    ret=0;
    if(y+game[y][x]<game.size())
        ret+=GetCnt(game,x,y+game[y][x]);
    if(x+game[y][x]<game.size())
        ret+=GetCnt(game,x+game[y][x],y);
    return ret;
}

int main()
{
    memset(memo,-1,sizeof(memo));
    int n;
    cin>>n;
    vector<vector<int>>game(n,vector<int>(n));
    for(int i=0;i<n;i++)
        for(int j=0;j<n;j++)
            cin>>game[i][j];
    cout<<GetCnt(game,0,0);
    return 0;
}
