/*백준 1029 그림교환
교환을 할 때 무조건 산가격이상을 사야 한다. 그리고 그림을 살 때는 그전에 샀던 가격의 이상의 가격으로 사야 하고 같은 그림을 두 번 이상 
사는 건 불가능하다.
결국은 그림을 소유했던 사람의 수의 최대값을 구하는 문제인데,
처음에는 살 수 있는 가격중 제일 낮은 가격을 선택해 나가면 되는 그리디 해법을 생각했지만, 그게 최적의 답으로 가지않는다는
걸 몇가지 예로 알 수 있었고, 결국 브루트포스로 가능한 모든 조합을 찾는걸 생각해보았다.
다만, N이 15이하의 자연수, 그림가격이 9이하의 자연수 라 최악의 조합 가지를 생각해보면 15의9승이 나와 
주어진 수행시간 내 2초안에 풀기에는 불가능하다.
그리면 생각해볼만한 해법이 다이나믹인데
주어진 입력에 대해서 똑같은 출력을 내야하므로 , 입력의 상태의 수를 정의해보자면 
몇번째 사람한테 그림이 있는지, 지금 현재 그림가격 즉 다음은 이 가격보다 이상을 사야 한다. ->몇번째 사람한테 있는지, 지금가격 
두번째 조건인 같은 그림을 두번이상 사는 건 불 가능하다. -> 지금까지 그 그림을 소유했던 사람은 누구인지. 표현하는 값 (비트마스킹으로 구현 할거임)
총 3가지 상태에 대해 생각하면 그 앞에 뭐가 나왔든 똑같은 출력을 내야할 것인게 자명해보인다.
시간복잡도는 상태의 수 (2^N * N * 10)* 탐색(N) 으로 N이 15이하 자연수 값을 생각해보면 빠르진 않지만 시간내에 수행하는데는 
문제가 없을 것으로 보인다. 그리고 실제 탐색을 생각해보면 더 빠른 시간내에 수행 될 것이므로 
알고리즘 성능에 대해서는 문제가 없어 보인다.
실제로 32ms 나올정도로 빠른시간내에 수행되었다. 
++
이문제는 전형적인 다이나믹 알고리즘을 이용하여 푸는 문제였다. 입력에 대해 차원을 줄 일수 있는 방법이 있을 것
같지만 당장 생각해 본 방식으로 충분히 빠른시간내에 풀었기에 더 나아가진 않았다.
*/

#include <iostream>
#include <string.h>
#include <vector>
#include <cmath>

using namespace std;

int memo[(int)pow(2,15)][15][10];

int GetCnt(vector<vector<int>>&ary,int list,int who,int price)
{
    int &ret=memo[list][who][price];
    if(ret!=-1) return ret;
    ret=1;
    for(int i=0;i<ary.size();i++)
    {
        if((list&(1<<i))==0 and ary[who][i]>=price)
        {
            ret=max(ret,1+GetCnt(ary,(list|(1<<i)),i,ary[who][i]));
        }
    }
    return ret;
    
}
int main()
{
    memset(memo,-1,sizeof(memo));
    int N;
    cin>>N;
    vector<vector<int>>ary(N,vector<int>(N));
    string val;
    for(int i=0;i<N;i++)
    {
        cin>>val;
        for(int j=0;j<N;j++)
            ary[i][j]=int(val[j])-48;
    }
    
    cout<<GetCnt(ary,1,0,0);
    
    return 0;
}
