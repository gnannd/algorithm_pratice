/*2023 KAKAO BLIND RECRUITMENT 미로 탈출 명령어
격자판이 주어지고 출발점과 도착점이 주어진다. 그리고 k(<=2500)이 주어지는데,
이 때 상하좌우 이동을 할 수 있고 이를 문자로 표현할 수 있다. 같은 격자를 두번이상 
방문할 수 있으며 도착점에 k만큼 거리로 이동해야 하며, 경로를 문자열로 표현할 때
사전 순 빠른 경로를 출력해야 한다. 그리고 불가능한 경우 impossible을 출력한다.
격자판의 크기는 제한은 50*50
이 문제를 풀기 위해 제일 먼저 떠오르는 건 너비 우선 탐색 이다. 하지만 그냥 
쓰기엔 격자가 중복이 된다는 점 k가 2500이하라는 점에서 경우의 수는 4(상하좌우)의 거듭제곱으로 무수히 
커질 것이다. 
이때 생각할 수 있는것은 다이나믹이다. 
입력의 상태를 격자판의 상태, k까지 남은거리 로 주어지면 결과값은 늘 똑같을 것이다. 
이때 결과를 도착점까지의 경로문자열 이라고 생각하면 우리가 원하는 답을 얻을 수 있다.
시간복잡도를 생각하면 격자판의 상태 (50*50) * 현재까지 거리 (k: 2500) * 탐색(상하좌우 4) 으로 충분히 시간내에
수행 가능하다.
참고로 문자열 사전순 이것은 탐색을 사전순으로 맞추면 해결가능하다.

*/
#include <string>
#include <vector>
#include <cstring>

using namespace std;
string memo[51][51][2501];
int dy[4]={1,0,0,-1}; //사전순으로 나오도록 맞춰줘야함.
int dx[4]={0,-1,1,0};
char dz[4]={'d','l','r','u'};
string get_path(int n,int m,int x,int y,int r,int c,int k) //경로의 길이를 반환.
{
    if(k==0)
    {
        if(x==r and y==c)
        {
            return "";
        }
        else
        {
            return "impossible";
        }
    }
    string &ret=memo[x][y][k];
    if(!ret.empty()) return ret;
    ret="impossible"; //어떤경로도 답이 될 수 없으면.
    for(int i=0;i<4;i++)
    {
        if(x+dy[i]<=n and x+dy[i]>=1 and y+dx[i]<=m and y+dx[i]>=1)
        {
            string p=get_path(n,m,x+dy[i],y+dx[i],r,c,k-1);
            if(p!="impossible")
            {
                ret=dz[i]+p;
                break;
            }
        }
    }
    return ret;
}


string solution(int n, int m, int x, int y, int r, int c, int k) {
    

    
    
    string answer = "";
    answer = get_path(n,m,x,y,r,c,k);
    
    return answer;
}
