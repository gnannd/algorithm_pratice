메모제이션을 문제의 답을 여러번 계산하는 중복계산을 피하는 패러다임.
참조적 투명성이 만족되어야 함.(입력이 같은데 외부요소에 따라 다른 값이 반환되면 안됨.)
즉, 입력값이 동일하면 출력도 동일해야만 사용할 수 있음.
많이 사용하는 기법이기에 나만의 한가지 틀만을 만들어두는게 실수방지에도 좋음.
추가로, 비둘기집 원리가 제일 많이 사용되는 유형임.

최적화문제에서도 많이 사용되는데, 최적부분구조가 성립하는 경우에 한해서다.
최적부분구조란 각 부분문제의 최적해만 있으면 전체 문제의 최적해를 얻어낼 수 있는 구조를 의미한다.
결국 최적을 구하는데 동적게획법이 사용된다는 것은 이전에 선택과 상관없이 각 부분 문제를 최적으로 풀기만 하면 전체문제의 최적해도 구할 수 잇다는 것이다.
최적부분구조가 성립되도록 입력 개수를 늘리던가 형태를 바꾸던가 해서 성립시켜 사용한다.

메모제이션을 쓸 때 입력값을 받게 되는데, 이때 참조적투명성을 만족하면서 여러 다양한 입력값을 처리하는 기교에 대해.
1대1 대응시키는게 중요.
-연관배열 사용(ex. map) : vector를 key로 받아 계산 
장점: vector 컨테이너 자체에 비교함수가 있어 간편하게 구현 가능. 단점: 비교자체가 오래걸려 계산량이 적은 경우 사용.
-1대1 대응 함수 만들기 : 
입력이 boolean 배열인 경우 비트마스크 이용 -> 지수 시간이 걸리게 때문에 이것도 크기가 작은 경우 사용.(알고리즘 자체가 지수시간 이상인 경우 사용하기 좋음)
입력이 순열인 경우 사전식으로 몇번째 인지 값을 반환하는 함수 만들어 사용->n이 크면 당연히 쓰기 힘듬. 시간도 n!임. 
입력이 범위가 좁을 경우: 배열의 길이가 n이고 범위가[0,k-1]이면 n자리의 k진수로 보기. k^n-1 이여서 k작으면 쓰기 유용함.
